@inproceedings{10.1145/2597073.2597110,
  author    = {Pinto, Gustavo and Castor, Fernando and Liu, Yu David},
  title     = {Mining questions about software energy consumption},
  year      = {2014},
  isbn      = {9781450328630},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2597073.2597110},
  doi       = {10.1145/2597073.2597110},
  abstract  = {A growing number of software solutions have been proposed to address application-level energy consumption problems in the last few years. However, little is known about how much software developers are concerned about energy consumption, what aspects of energy consumption they consider important, and what solutions they have in mind for improving energy efficiency. In this paper we present the first empirical study on understanding the views of application programmers on software energy consumption problems. Using StackOverflow as our primary data source, we analyze a carefully curated sample of more than 300 questions and 550 answers from more than 800 users. With this data, we observed a number of interesting findings. Our study shows that practitioners are aware of the energy consumption problems: the questions they ask are not only diverse -- we found 5 main themes of questions -- but also often more interesting and challenging when compared to the control question set. Even though energy consumption-related questions are popular when considering a number of different popularity measures, the same cannot be said about the quality of their answers. In addition, we observed that some of these answers are often flawed or vague. We contrast the advice provided by these answers with the state-of-the-art research on energy consumption. Our summary of software energy consumption problems may help researchers focus on what matters the most to software developers and end users.},
  booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories},
  pages     = {22–31},
  numpages  = {10},
  keywords  = {Software Energy Consumption, Q&A, Practitioners},
  location  = {Hyderabad, India},
  series    = {MSR 2014}
}

@article{balaras2017high,
  title     = {High performance data centers and energy efficiency potential in Greece},
  author    = {Balaras, Constantinos A and Lelekis, John and Dascalaki, Elena G and Atsidaftis, Dimitris},
  journal   = {Procedia environmental sciences},
  volume    = {38},
  pages     = {107--114},
  year      = {2017},
  publisher = {Elsevier}
}

@article{estrada2022learning,
  title     = {Learning-based energy consumption prediction},
  author    = {Estrada, Rebeca and Torres, Danny and Bazurto, Adrian and Valeriano, Irving and others},
  journal   = {Procedia Computer Science},
  volume    = {203},
  pages     = {272--279},
  year      = {2022},
  publisher = {Elsevier}
}

@misc{google_adaptive_battery,
  author       = {Google Support},
  title        = {Adaptive Battery},
  howpublished = {\url{https://support.google.com/pixelphone/answer/7015477?hl=en}},
  note         = {Accessed: 2025-01-02}
}

@misc{google_battery_saver,
  author       = {Google Support},
  title        = {Use Battery Saver on Android},
  howpublished = {\url{https://support.google.com/android/answer/7664692?hl=en}},
  note         = {Accessed: 2025-01-02}
}

@misc{apple_clean_energy,
  author       = {Apple Support},
  title        = {Use Clean Energy Charging on Your iPhone},
  howpublished = {\url{https://support.apple.com/en-us/108068#:~:text=With%20iPhone%2015%20models%20and,Clean%20Energy%20Charging%20is%20on.}},
  note         = {Accessed: 2025-01-02}
}
@misc{android_power_profiler,
  author       = {Android Developers},
  title        = {Power Profiler for Android Studio},
  howpublished = {\url{https://developer.android.com/studio/profile/power-profiler}},
  note         = {Accessed: 2025-01-02}
}

@misc{fonseca2022typesystemsresourceawareprogramming,
  title         = {Type Systems in Resource-Aware Programming: Opportunities and Challenges},
  author        = {Alcides Fonseca and Guilherme Espada},
  year          = {2022},
  eprint        = {2205.15211},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/2205.15211}
}

@article{10.1145/3154384,
  author     = {Pinto, Gustavo and Castor, Fernando},
  title      = {Energy efficiency: a new concern for application software developers},
  year       = {2017},
  issue_date = {December 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {60},
  number     = {12},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/3154384},
  doi        = {10.1145/3154384},
  abstract   = {Development of energy-efficient software is hindered by a lack of knowledge and a lack of tools.},
  journal    = {Commun. ACM},
  month      = nov,
  pages      = {68–75},
  numpages   = {8}
}

@article{10.1145/2094091.2094106,
  author     = {H\"{o}nig, Timo and Eibel, Christopher and Kapitza, R\"{u}diger and Schr\"{o}der-Preikschat, Wolfgang},
  title      = {SEEP: exploiting symbolic execution for energy-aware programming},
  year       = {2012},
  issue_date = {December 2011},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {45},
  number     = {3},
  issn       = {0163-5980},
  url        = {https://doi.org/10.1145/2094091.2094106},
  doi        = {10.1145/2094091.2094106},
  abstract   = {In recent years, there has been a rapid evolution of energyaware computing systems (e.g., mobile devices, wireless sensor nodes), as still rising system complexity and increasing user demands make energy a permanently scarce resource. While static and dynamic optimizations for energy-aware execution have been explored massively, writing energyefficient programs in the first place has only received limited attention. This paper proposes SEEP, a framework which exploits symbolic execution and platform-specific energy profiles to provide the basis for energy-aware programming. More specifically, the framework provides developers with information about the energy demand of their code at hand, even for the invocation of library functions and in settings with multiple possibly strongly heterogeneous target platforms. This equips developers with the necessary knowledge to take energy demand into account during the task of writing programs.},
  journal    = {SIGOPS Oper. Syst. Rev.},
  month      = jan,
  pages      = {58–62},
  numpages   = {5}
}

@inproceedings{187026,
  author    = {Timo H{\"o}nig and Heiko Janker and Christopher Eibel and Oliver Mihelic and R{\"u}diger Kapitza},
  title     = {Proactive {Energy-Aware} Programming with {PEEK}},
  booktitle = {2014 Conference on Timely Results in Operating Systems (TRIOS 14)},
  year      = {2014},
  address   = {Broomfield, CO},
  url       = {https://www.usenix.org/conference/trios14/technical-sessions/presentation/hoenig},
  publisher = {USENIX Association},
  month     = oct
}

@inproceedings{10.1145/2896967.2896968,
  author    = {Pereira, Rui and Couto, Marco and Saraiva, Jo\~{a}o and Cunha, J\'{a}come and Fernandes, Jo\~{a}o Paulo},
  title     = {The influence of the Java collection framework on overall energy consumption},
  year      = {2016},
  isbn      = {9781450341615},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2896967.2896968},
  doi       = {10.1145/2896967.2896968},
  abstract  = {This paper presents a detailed study of the energy consumption of the different Java Collection Framework (JFC) implementations. For each method of an implementation in this framework, we present its energy consumption when handling different amounts of data. Knowing the greenest methods for each implementation, we present an energy optimization approach for Java programs: based on calls to JFC methods in the source code of a program, we select the greenest implementation. Finally, we present preliminary results of optimizing a set of Java programs where we obtained 6.2\% energy savings.},
  booktitle = {Proceedings of the 5th International Workshop on Green and Sustainable Software},
  pages     = {15–21},
  numpages  = {7},
  keywords  = {energy-aware software, green computing},
  location  = {Austin, Texas},
  series    = {GREENS '16}
}

@inproceedings{10.5555/1267847.1267870,
  author    = {Vijaykrishnan, N. and Kandemir, M. and Kim, S. and Tomar, S. and Sivasubramaniam, A. and Irwin, M. J.},
  title     = {Energy behavior of java applications from the memory perspective},
  year      = {2001},
  publisher = {USENIX Association},
  address   = {USA},
  abstract  = {With the anticipated dramatic growth of computing devices for mobile and embedded environments, energy conscious hardware and software design has taken center-stage together with performance. At the same time, there is an increasing need to provide a portable and seamless software environment for application development and interoperability. This paper takes an important step in the confluence of these two emerging trends, by examining the energy behavior of the memory system in the execution of Java applications. It is crucial to understand and optimize the energy behavior of the memory system since instructions referencing memory can contribute to a large fraction of the energy consumption when executing Java applications.Using an off-the-shelf JVM, a validated memory energy model, and a detailed simulator, this paper presents a characterization of the energy consumption by the cache and main memory when executing the SPEC JVM98 benchmarks in the JIT and interpreter modes. The energy consumption is profiled for the different hard-ware components (instruction cache, data cache, memory) and software components (class loading, garbage collection, dynamic compilation). The results from such a characterization are useful to the hardware designer for cache organizations and architectural enhancements for reducing energy consumption. They are also useful to the application and runtime system designer to identify energy bottlenecks, and for code restructuring or algorithm redesign to alleviate these bottlenecks.},
  booktitle = {Proceedings of the 2001 Symposium on JavaTM Virtual Machine Research and Technology Symposium - Volume 1},
  pages     = {23},
  numpages  = {1},
  location  = {Monterey, California},
  series    = {JVM'01}
}

@article{annurev:/content/journals/10.1146/annurev.resource.102308.124234,
  author    = {Gillingham, Kenneth and Newell, Richard G. and Palmer, Karen},
  title     = {Energy Efficiency Economics and Policy},
  journal   = {Annual Review of Resource Economics},
  year      = {2009},
  volume    = {1},
  number    = {Volume 1, 2009},
  pages     = {597-620},
  doi       = {https://doi.org/10.1146/annurev.resource.102308.124234},
  url       = {https://www.annualreviews.org/content/journals/10.1146/annurev.resource.102308.124234},
  publisher = {Annual Reviews},
  issn      = {1941-1359},
  type      = {Journal Article},
  keywords  = {appliance standards},
  keywords  = {behavioral failures},
  keywords  = {market failures},
  abstract  = {Energy efficiency and conservation are considered key means for reducing greenhouse gas emissions and achieving other energy policy goals, but associated market behavior and policy responses have engendered debates in the economic literature. We review economic concepts underlying consumer decision making in energy efficiency and conservation and examine related empirical literature. In particular, we provide an economic perspective on the range of market barriers, market failures, and behavioral failures that have been cited in the energy efficiency context. We assess the extent to which these conditions provide a motivation for policy intervention in energy-using product markets, including an examination of the evidence on policy effectiveness and cost. Although theory and empirical evidence suggests there is potential for welfare-enhancing energy efficiency policies, many open questions remain, particularly relating to the extent of some key market and behavioral failures.}
}


@article{10.1145/1666420.1666438,
  author     = {Brown, David J. and Reams, Charles},
  title      = {Toward energy-efficient computing},
  year       = {2010},
  issue_date = {March 2010},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {53},
  number     = {3},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/1666420.1666438},
  doi        = {10.1145/1666420.1666438},
  abstract   = {What will it take to make server-side computing more energy efficient?},
  journal    = {Commun. ACM},
  month      = mar,
  pages      = {50–58},
  numpages   = {9}
}

@inproceedings{10.1145/3238147.3240473,
  author    = {Pereira, Rui and Sim\~{a}o, Pedro and Cunha, J\'{a}come and Saraiva, Jo\~{a}o},
  title     = {jStanley: placing a green thumb on Java collections},
  year      = {2018},
  isbn      = {9781450359375},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3238147.3240473},
  doi       = {10.1145/3238147.3240473},
  abstract  = {Software developers are more and more eager to understand their code’s energy performance. However, even with such knowledge it is di cult to know how to improve the code. Indeed, little tool support exists to understand the energy consumption pro le of a software system and to eventually (automatically) improve its code.  In this paper we present a tool termed jStanley which automatically nds collections in Java programs that can be replaced by others with a positive impact on the energy consumption as well as on the execution time. In seconds, developers obtain information about energy-eager collection usage. jStanley will further suggest alternative collections to improve the code, making it use less time, energy, or a combination of both. The preliminary evaluation we ran using jStanley shows energy gains between 2\% and 17\%, and a reduction in execution time between 2\% and 13\%.  A video can be seen at https://greensoftwarelab.github.io/jStanley.},
  booktitle = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
  pages     = {856–859},
  numpages  = {4},
  keywords  = {Eclipse Plugin, Energy Efficiency, Energy-aware Software, Green Software, Java Collection Framework},
  location  = {Montpellier, France},
  series    = {ASE '18}
}


@inproceedings{8816747,
  author    = {Oliveira, Wellington and Oliveira, Renato and Castor, Fernando and Fernandes, Benito and Pinto, Gustavo},
  booktitle = {2019 IEEE/ACM 16th International Conference on Mining Software Repositories (MSR)},
  title     = {Recommending Energy-Efficient Java Collections},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {160-170},
  keywords  = {Java;Energy consumption;Tools;Software systems;Static analysis;Synchronization;Energy Consumption;Benchmarks;Refactoring;Static Analysis;Optimization;Mobile;Collections},
  doi       = {10.1109/MSR.2019.00033}
}

@inproceedings{vartziotis2024carbon,
  title={Carbon Footprint Evaluation of Code Generation through LLM as a Service},
  author={Vartziotis, Tina and Schmidt, Maximilian and Dasoulas, George and Dellatolas, Ippolyti and Attademo, Stefano and Le, Viet Dung and Wiechmann, Anke and Hoffmann, Tim and Keckeisen, Michael and Kotsopoulos, Sotirios},
  booktitle={International Stuttgart Symposium},
  pages={230--241},
  year={2024},
  organization={Springer}
}

@article{rani2025can,
  title={Can We Make Code Green? Understanding Trade-Offs in LLMs vs. Human Code Optimizations},
  author={Rani, Pooja and Bard, Jan-Andrea and Sallou, June and Boll, Alexander and Kehrer, Timo and Bacchelli, Alberto},
  journal={arXiv preprint arXiv:2503.20126},
  year={2025}
}

@inproceedings{10.1145/3550355.3552452,
author = {Barros, Djonathan and Peldszus, Sven and Assun\c{c}\~{a}o, Wesley K. G. and Berger, Thorsten},
title = {Editing support for software languages: implementation practices in language server protocols},
year = {2022},
isbn = {9781450394666},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3550355.3552452},
doi = {10.1145/3550355.3552452},
abstract = {Effectively using software languages, be it programming or domain-specific languages, requires effective editing support. Modern IDEs, modeling tools, and code editors typically provide sophisticated support to create, comprehend, or modify instances---programs or models---of particular languages. Unfortunately, building such editing support is challenging. While the engineering of languages is well understood and supported by modern model-driven techniques, there is a lack of engineering principles and best practices for realizing their editing support. Especially domain-specific languages---often created by smaller organizations or individual developers, sometimes even for single projects---would benefit from better methods and tools to create proper editing support.We study practices for implementing editing support in 30 so-called language servers---implementations of the language server protocol (LSP). The latter is a recent de facto standard to realize editing support for languages, separated from the editing tools (e.g., IDEs or modeling tools), enhancing the reusability and quality of the editing support. Witnessing the LSP's popularity---a whopping 121 language servers are in existence today---we take this opportunity to analyze the implementations of 30 language servers, some of which support multiple languages. We identify concerns that developers need to take into account when developing editing support, and we synthesize implementation practices to address them, based on a systematic analysis of the servers' source code. We hope that our results shed light on an important technology for software language engineering, that facilitates language-oriented programming and systems development, including model-driven engineering.},
booktitle = {Proceedings of the 25th International Conference on Model Driven Engineering Languages and Systems},
pages = {232–243},
numpages = {12},
keywords = {code assistance, implementation practices, language engineering, source code editor},
location = {Montreal, Quebec, Canada},
series = {MODELS '22}
}

@inproceedings{10.1145/2884781.2884869,
  author    = {Hasan, Samir and King, Zachary and Hafiz, Munawar and Sayagh, Mohammed and Adams, Bram and Hindle, Abram},
  title     = {Energy profiles of Java collections classes},
  year      = {2016},
  isbn      = {9781450339001},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2884781.2884869},
  doi       = {10.1145/2884781.2884869},
  abstract  = {We created detailed profiles of the energy consumed by common operations done on Java List, Map, and Set abstractions. The results show that the alternative data types for these abstractions differ significantly in terms of energy consumption depending on the operations. For example, an ArrayList consumes less energy than a LinkedList if items are inserted at the middle or at the end, but consumes more energy than a LinkedList if items are inserted at the start of the list. To explain the results, we explored the memory usage and the bytecode executed during an operation. Expensive computation tasks in the analyzed bytecode traces appeared to have an energy impact, but memory usage did not contribute. We evaluated our profiles by using them to selectively replace Collections types used in six applications and libraries. We found that choosing the wrong Collections type, as indicated by our profiles, can cost even 300\% more energy than the most efficient choice. Our work shows that the usage context of a data structure and our measured energy profiles can be used to decide between alternative Collections implementations.},
  booktitle = {Proceedings of the 38th International Conference on Software Engineering},
  pages     = {225–236},
  numpages  = {12},
  keywords  = {energy profile, collections, Java, API},
  location  = {Austin, Texas},
  series    = {ICSE '16}
}

@article{10.1145/3140587.3062356,
  author     = {Canino, Anthony and Liu, Yu David},
  title      = {Proactive and adaptive energy-aware programming with mixed typechecking},
  year       = {2017},
  issue_date = {June 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3140587.3062356},
  doi        = {10.1145/3140587.3062356},
  abstract   = {Application-level energy management is an important dimension of energy optimization. In this paper, we introduce ENT, a novel programming language for enabling *proactive* and *adaptive* mode-based energy management at the application level. The proactive design allows programmers to apply their application knowledge to energy management, by characterizing the energy behavior of different program fragments with modes. The adaptive design allows such characterization to be delayed until run time, useful for capturing dynamic program behavior dependent on program states, configuration settings, external battery levels, or CPU temperatures. The key insight is both proactiveness and adaptiveness can be unified under a type system combined with static typing and dynamic typing. ENT has been implemented as an extension to Java, and successfully ported to three energy-conscious platforms: an Intel-based laptop, a Raspberry Pi, and an Android phone. Evaluation shows ENT improves the programmability, debuggability, and energy efficiency of battery-aware and temperature-aware programs.},
  journal    = {SIGPLAN Not.},
  month      = jun,
  pages      = {217–232},
  numpages   = {16},
  keywords   = {Type systems, Energy-Aware Programming, Energy Efficiency}
}

@article{10.1145/1297105.1297033,
author = {Georges, Andy and Buytaert, Dries and Eeckhout, Lieven},
title = {Statistically rigorous java performance evaluation},
year = {2007},
issue_date = {October 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1297105.1297033},
doi = {10.1145/1297105.1297033},
abstract = {Java performance is far from being trivial to benchmark because it is affected by various factors such as the Java application, its input, the virtual machine, the garbage collector, the heap size, etc. In addition, non-determinism at run-time causes the execution time of a Java program to differ from run to run. There are a number of sources of non-determinism such as Just-In-Time (JIT) compilation and optimization in the virtual machine (VM) driven by timer-based method sampling, thread scheduling, garbage collection, and various.There exist a wide variety of Java performance evaluation methodologies usedby researchers and benchmarkers. These methodologies differ from each other in a number of ways. Some report average performance over a number of runs of the same experiment; others report the best or second best performance observed; yet others report the worst. Some iterate the benchmark multiple times within a single VM invocation; others consider multiple VM invocations and iterate a single benchmark execution; yet others consider multiple VM invocations and iterate the benchmark multiple times.This paper shows that prevalent methodologies can be misleading, and can even lead to incorrect conclusions. The reason is that the data analysis is not statistically rigorous. In this paper, we present a survey of existing Java performance evaluation methodologies and discuss the importance of statistically rigorous data analysis for dealing with non-determinism. We advocate approaches to quantify startup as well as steady-state performance, and, in addition, we provide the JavaStats software to automatically obtain performance numbers in a rigorous manner. Although this paper focuses on Java performance evaluation, many of the issues addressed in this paper also apply to other programming languages and systems that build on a managed runtime system.},
journal = {SIGPLAN Not.},
month = oct,
pages = {57–76},
numpages = {20},
keywords = {statistics, methodology, java, data analysis, benchmarking}
}

@inproceedings{10.1145/1297027.1297033,
author = {Georges, Andy and Buytaert, Dries and Eeckhout, Lieven},
title = {Statistically rigorous java performance evaluation},
year = {2007},
isbn = {9781595937865},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1297027.1297033},
doi = {10.1145/1297027.1297033},
abstract = {Java performance is far from being trivial to benchmark because it is affected by various factors such as the Java application, its input, the virtual machine, the garbage collector, the heap size, etc. In addition, non-determinism at run-time causes the execution time of a Java program to differ from run to run. There are a number of sources of non-determinism such as Just-In-Time (JIT) compilation and optimization in the virtual machine (VM) driven by timer-based method sampling, thread scheduling, garbage collection, and various.There exist a wide variety of Java performance evaluation methodologies usedby researchers and benchmarkers. These methodologies differ from each other in a number of ways. Some report average performance over a number of runs of the same experiment; others report the best or second best performance observed; yet others report the worst. Some iterate the benchmark multiple times within a single VM invocation; others consider multiple VM invocations and iterate a single benchmark execution; yet others consider multiple VM invocations and iterate the benchmark multiple times.This paper shows that prevalent methodologies can be misleading, and can even lead to incorrect conclusions. The reason is that the data analysis is not statistically rigorous. In this paper, we present a survey of existing Java performance evaluation methodologies and discuss the importance of statistically rigorous data analysis for dealing with non-determinism. We advocate approaches to quantify startup as well as steady-state performance, and, in addition, we provide the JavaStats software to automatically obtain performance numbers in a rigorous manner. Although this paper focuses on Java performance evaluation, many of the issues addressed in this paper also apply to other programming languages and systems that build on a managed runtime system.},
booktitle = {Proceedings of the 22nd Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications},
pages = {57–76},
numpages = {20},
keywords = {java, data analysis, benchmarking, statistics, methodology},
location = {Montreal, Quebec, Canada},
series = {OOPSLA '07}
}

@inproceedings{10.1145/1167473.1167488,
author = {Blackburn, Stephen M. and Garner, Robin and Hoffmann, Chris and Khang, Asjad M. and McKinley, Kathryn S. and Bentzur, Rotem and Diwan, Amer and Feinberg, Daniel and Frampton, Daniel and Guyer, Samuel Z. and Hirzel, Martin and Hosking, Antony and Jump, Maria and Lee, Han and Moss, J. Eliot B. and Phansalkar, Aashish and Stefanovi\'{c}, Darko and VanDrunen, Thomas and von Dincklage, Daniel and Wiedermann, Ben},
title = {The DaCapo benchmarks: java benchmarking development and analysis},
year = {2006},
isbn = {1595933484},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1167473.1167488},
doi = {10.1145/1167473.1167488},
abstract = {Since benchmarks drive computer science research and industry product development, which ones we use and how we evaluate them are key questions for the community. Despite complex runtime tradeoffs due to dynamic compilation and garbage collection required for Java programs, many evaluations still use methodologies developed for C, C++, and Fortran. SPEC, the dominant purveyor of benchmarks, compounded this problem by institutionalizing these methodologies for their Java benchmark suite. This paper recommends benchmarking selection and evaluation methodologies, and introduces the DaCapo benchmarks, a set of open source, client-side Java benchmarks. We demonstrate that the complex interactions of (1) architecture, (2) compiler, (3) virtual machine, (4) memory management, and (5) application require more extensive evaluation than C, C++, and Fortran which stress (4) much less, and do not require (3). We use and introduce new value, time-series, and statistical metrics for static and dynamic properties such as code complexity, code size, heap composition, and pointer mutations. No benchmark suite is definitive, but these metrics show that DaCapo improves over SPEC Java in a variety of ways, including more complex code, richer object behaviors, and more demanding memory system requirements. This paper takes a step towards improving methodologies for choosing and evaluating benchmarks to foster innovation in system design and implementation for Java and other managed languages.},
booktitle = {Proceedings of the 21st Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages, and Applications},
pages = {169–190},
numpages = {22},
keywords = {DaCapo, Java, SPEC, benchmark, methodology},
location = {Portland, Oregon, USA},
series = {OOPSLA '06}
}

@article{10.1145/1167515.1167488,
author = {Blackburn, Stephen M. and Garner, Robin and Hoffmann, Chris and Khang, Asjad M. and McKinley, Kathryn S. and Bentzur, Rotem and Diwan, Amer and Feinberg, Daniel and Frampton, Daniel and Guyer, Samuel Z. and Hirzel, Martin and Hosking, Antony and Jump, Maria and Lee, Han and Moss, J. Eliot B. and Phansalkar, Aashish and Stefanovi\'{c}, Darko and VanDrunen, Thomas and von Dincklage, Daniel and Wiedermann, Ben},
title = {The DaCapo benchmarks: java benchmarking development and analysis},
year = {2006},
issue_date = {October 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {41},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1167515.1167488},
doi = {10.1145/1167515.1167488},
abstract = {Since benchmarks drive computer science research and industry product development, which ones we use and how we evaluate them are key questions for the community. Despite complex runtime tradeoffs due to dynamic compilation and garbage collection required for Java programs, many evaluations still use methodologies developed for C, C++, and Fortran. SPEC, the dominant purveyor of benchmarks, compounded this problem by institutionalizing these methodologies for their Java benchmark suite. This paper recommends benchmarking selection and evaluation methodologies, and introduces the DaCapo benchmarks, a set of open source, client-side Java benchmarks. We demonstrate that the complex interactions of (1) architecture, (2) compiler, (3) virtual machine, (4) memory management, and (5) application require more extensive evaluation than C, C++, and Fortran which stress (4) much less, and do not require (3). We use and introduce new value, time-series, and statistical metrics for static and dynamic properties such as code complexity, code size, heap composition, and pointer mutations. No benchmark suite is definitive, but these metrics show that DaCapo improves over SPEC Java in a variety of ways, including more complex code, richer object behaviors, and more demanding memory system requirements. This paper takes a step towards improving methodologies for choosing and evaluating benchmarks to foster innovation in system design and implementation for Java and other managed languages.},
journal = {SIGPLAN Not.},
month = oct,
pages = {169–190},
numpages = {22},
keywords = {DaCapo, Java, SPEC, benchmark, methodology}
}



@inproceedings{10.1145/3062341.3062356,
  author    = {Canino, Anthony and Liu, Yu David},
  title     = {Proactive and adaptive energy-aware programming with mixed typechecking},
  year      = {2017},
  isbn      = {9781450349888},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3062341.3062356},
  doi       = {10.1145/3062341.3062356},
  abstract  = {Application-level energy management is an important dimension of energy optimization. In this paper, we introduce ENT, a novel programming language for enabling *proactive* and *adaptive* mode-based energy management at the application level. The proactive design allows programmers to apply their application knowledge to energy management, by characterizing the energy behavior of different program fragments with modes. The adaptive design allows such characterization to be delayed until run time, useful for capturing dynamic program behavior dependent on program states, configuration settings, external battery levels, or CPU temperatures. The key insight is both proactiveness and adaptiveness can be unified under a type system combined with static typing and dynamic typing. ENT has been implemented as an extension to Java, and successfully ported to three energy-conscious platforms: an Intel-based laptop, a Raspberry Pi, and an Android phone. Evaluation shows ENT improves the programmability, debuggability, and energy efficiency of battery-aware and temperature-aware programs.},
  booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {217–232},
  numpages  = {16},
  keywords  = {Type systems, Energy-Aware Programming, Energy Efficiency},
  location  = {Barcelona, Spain},
  series    = {PLDI 2017}
}

@inproceedings{7816451,
  author    = {Pinto, Gustavo and Liu, Kenan and Castor, Fernando and Liu, Yu David},
  booktitle = {2016 IEEE International Conference on Software Maintenance and Evolution (ICSME)},
  title     = {A Comprehensive Study on the Energy Efficiency of Java’s Thread-Safe Collections},
  year      = {2016},
  volume    = {},
  number    = {},
  pages     = {20-31},
  keywords  = {Energy consumption;Java;Programming;Optimization;Servers;Energy measurement;Data structures},
  doi       = {10.1109/ICSME.2016.34}
}

@inproceedings{noureddine-ie-2022,
  title     = {PowerJoular and JoularJX: Multi-Platform Software Power Monitoring Tools},
  author    = {Noureddine, Adel},
  booktitle = {18th International Conference on Intelligent Environments (IE2022)},
  address   = {Biarritz, France},
  year      = {2022},
  month     = {Jun},
  keywords  = {Power Monitoring; Measurement; Power Consumption; Energy Analysis}
}

@article{article,
  author  = {Andrae, Anders},
  year    = {2020},
  month   = {06},
  pages   = {19-31},
  title   = {New perspectives on internet electricity use in 2030},
  volume  = {3},
  journal = {Engineering and Applied Science Letters},
  doi     = {10.30538/psrp-easl2020.0038}
}

@inproceedings{ernst2003static,
  title     = {Static and dynamic analysis: Synergy and duality},
  author    = {Ernst, Michael D},
  booktitle = {WODA 2003: ICSE Workshop on Dynamic Analysis},
  pages     = {24--27},
  year      = {2003}
}

@article{aggarwal2014power,
  title  = {The power of system call traces: Predicting the software energy consumption impact of changes},
  author = {Aggarwal, Karan and Chenlei, Z and Campbell, J and Hindle, Abram and Stroulia, Eleni},
  year   = {2014}
}

@article{patterson2021carbon,
  title   = {Carbon emissions and large neural network training},
  author  = {Patterson, David and Gonzalez, Joseph and Le, Quoc and Liang, Chen and Munguia, Lluis-Miquel and Rothchild, Daniel and So, David and Texier, Maud and Dean, Jeff},
  journal = {arXiv preprint arXiv:2104.10350},
  year    = {2021}
}

@inproceedings{7194624,
  author    = {Zhu, Haitao Steve and Lin, Chaoren and Liu, Yu David},
  booktitle = {2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
  title     = {A Programming Model for Sustainable Software},
  year      = {2015},
  volume    = {1},
  number    = {},
  pages     = {767-777},
  keywords  = {Programming;Batteries;Runtime;Calibration;Thermal management;Software;Java;sustainability;programming models;energy management;thermal management},
  doi       = {10.1109/ICSE.2015.89}
}

  @article{8880037,
  author   = {Fonseca, Alcides and Kazman, Rick and Lago, Patricia},
  journal  = {IEEE Software},
  title    = {A Manifesto for Energy-Aware Software},
  year     = {2019},
  volume   = {36},
  number   = {6},
  pages    = {79-82},
  keywords = {Software engineering;Energy efficiency;Energy consumption;Market research;Complexity theory;Information and communication technology},
  doi      = {10.1109/MS.2019.2924498}
}

  @software{S2_Group_Experiment_Runner,
  author  = {{S2 Group}},
  license = {MIT},
  title   = {{Experiment Runner}},
  url     = {https://github.com/s2-group/experiment-runner/},
  note    = {Retrieved November 15, 2024 from https://github.com/s2-group/experiment-runner/}
}


@misc{archlinux_powertop,
  author = {{Arch Linux Wiki contributors}},
  title  = {Powertop},
  year   = 2024,
  url    = {https://wiki.archlinux.org/title/Powertop},
  note   = {Last edited on 26 April 2024, at 18:46. Retrieved December 2, 2024 from https://wiki.archlinux.org/title/Powertop}
}

@misc{perfwiki_main,
  author = {{PerfWiki contributors}},
  title  = {{PerfWiki: Main Page}},
  year   = 2024,
  url    = {https://perfwiki.github.io/main/},
  note   = {Last edited on 1 December 2024. Retrieved December 2, 2024 from https://perfwiki.github.io/main/}
}

//https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/

@misc{lsp,
  author       = {{Microsoft}},
  title        = {Language Server Protocol Overview},
  year         = {2025},
  howpublished = {https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/},
  note         = {Retrieved July 30, 2025 from https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/}
}


@article{PEREIRA2021102609,
  title    = {Ranking programming languages by energy efficiency},
  journal  = {Science of Computer Programming},
  volume   = {205},
  pages    = {102609},
  year     = {2021},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2021.102609},
  url      = {https://www.sciencedirect.com/science/article/pii/S0167642321000022},
  author   = {Rui Pereira and Marco Couto and Francisco Ribeiro and Rui Rua and Jácome Cunha and João Paulo Fernandes and João Saraiva},
  keywords = {Energy efficiency, Programming languages, Language benchmarking, Green software},
  abstract = {This paper compares a large set of programming languages regarding their efficiency, including from an energetic point-of-view. Indeed, we seek to establish and analyze different rankings for programming languages based on their energy efficiency. The goal of being able to rank programming languages based on their energy efficiency is both recent, and certainly deserves further studies. We have taken rigorous and strict solutions to 10 well defined programming problems, expressed in (up to) 27 programming languages, from the well known Computer Language Benchmark Game repository. This repository aims to compare programming languages based on a strict set of implementation rules and configurations for each benchmarking problem. We have also built a framework to automatically, and systematically, run, measure and compare the energy, time, and memory efficiency of such solutions. Ultimately, it is based on such comparisons that we propose a series of efficiency rankings, based on single and multiple criteria. Our results show interesting findings, such as how slower/faster languages can consume less/more energy, and how memory usage influences energy consumption. We also present a simple way to use our results to provide software engineers and practitioners support in deciding which language to use when energy efficiency is a concern. In addition, we further validate our results and rankings against implementations from a chrestomathy program repository, Rosetta Code., by reproducing our methodology and benchmarking system. This allows us to understand how the results and conclusions from our rigorously and well defined benchmarked programs compare to those based on more representative and real-world implementations. Indeed our results show that the rankings do not change apart from one programming language.}
}

@article{ge2009powerpack,
  title     = {Powerpack: Energy profiling and analysis of high-performance systems and applications},
  author    = {Ge, Rong and Feng, Xizhou and Song, Shuaiwen and Chang, Hung-Ching and Li, Dong and Cameron, Kirk W},
  journal   = {IEEE Transactions on Parallel and Distributed Systems},
  volume    = {21},
  number    = {5},
  pages     = {658--671},
  year      = {2009},
  publisher = {IEEE}
}

@inproceedings{hackenberg2013power,
  title        = {Power measurement techniques on standard compute nodes: A quantitative comparison},
  author       = {Hackenberg, Daniel and Ilsche, Thomas and Sch{\"o}ne, Robert and Molka, Daniel and Schmidt, Maik and Nagel, Wolfgang E},
  booktitle    = {2013 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)},
  pages        = {194--204},
  year         = {2013},
  organization = {IEEE}
}

@article{sarker2021machine,
  title     = {Machine learning: Algorithms, real-world applications and research directions},
  author    = {Sarker, Iqbal H},
  journal   = {SN computer science},
  volume    = {2},
  number    = {3},
  pages     = {160},
  year      = {2021},
  publisher = {Springer}
}

@misc{wala_main,
  author = {{WALA contributors}},
  title  = {{WALA: Watson Libraries for Analysis}},
  year   = 2024,
  url    = {https://github.com/wala/WALA},
  note   = {Retrieved December 4, 2024 from https://github.com/wala/WALA}
}

@misc{sootup_main,
  author = {{SootUp contributors}},
  title  = {{SootUp: A Framework for Java Analysis and Transformation}},
  year   = 2024,
  url    = {https://soot-oss.github.io/SootUp/latest/},
  note   = {Retrieved December 4, 2024 from https://soot-oss.github.io/SootUp/latest/}
}

@misc{spoon_main,
  author = {{Spoon contributors}},
  title  = {{Spoon: Analyze and Transform Java Source Code}},
  year   = 2024,
  url    = {https://spoon.gforge.inria.fr/},
  note   = {Retrieved December 4, 2024 from https://spoon.gforge.inria.fr/}
}

@misc{javaParser,
  author = {{JavaParser contributors}},
  title  = {{JavaParser: A Parser and Abstract Syntax Tree Generator for Java}},
  year   = 2025,
  url    = {https://javaparser.org/},
  note   = {Retrieved June 2, 2025 from https://github.com/javaparser/javaparser/}
}

@inproceedings{8726531,
  author    = {Fu, Cuijiao and Qian, Depei and Luan, Zhongzhi},
  booktitle = {2018 IEEE International Conference on Internet of Things (iThings) and IEEE Green Computing and Communications (GreenCom) and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data (SmartData)},
  title     = {Estimating Software Energy Consumption with Machine Learning Approach by Software Performance Feature},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {490-496},
  keywords  = {Energy consumption;Software;Computational modeling;Hardware;Tools;Energy measurement;Energy efficiency;Software Energy Consumption;Energy-Efficiency;Measurement;Performance},
  doi       = {10.1109/Cybermatics_2018.2018.00106}
}

@misc{intel_rapl,
  author = {{Intel Corporation}},
  title  = {{Running Average Power Limit (RAPL) Energy Reporting}},
  year   = 2025,
  url    = {https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/running-average-power-limit-energy-reporting.html},
  note   = {Retrieved January 5, 2025, from https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/running-average-power-limit-energy-reporting.html}
}

@inproceedings{10.1145/3136014.3136031,
author = {Pereira, Rui and Couto, Marco and Ribeiro, Francisco and Rua, Rui and Cunha, J\'{a}come and Fernandes, Jo\~{a}o Paulo and Saraiva, Jo\~{a}o},
title = {Energy efficiency across programming languages: how do energy, time, and memory relate?},
year = {2017},
isbn = {9781450355254},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3136014.3136031},
doi = {10.1145/3136014.3136031},
abstract = {This paper presents a study of the runtime, memory usage and energy consumption of twenty seven well-known software languages. We monitor the performance of such languages using ten different programming problems, expressed in each of the languages. Our results show interesting findings, such as, slower/faster languages consuming less/more energy, and how memory usage influences energy consumption. Finally, we show how to use our results to provide software engineers support to decide which language to use when energy efficiency is a concern.},
booktitle = {Proceedings of the 10th ACM SIGPLAN International Conference on Software Language Engineering},
pages = {256–267},
numpages = {12},
keywords = {Energy Efficiency, Green Software, Language Benchmarking, Programming Languages},
location = {Vancouver, BC, Canada},
series = {SLE 2017}
}

@misc{cranmer2023interpretablemachinelearningscience,
      title={Interpretable Machine Learning for Science with PySR and SymbolicRegression.jl}, 
      author={Miles Cranmer},
      year={2023},
      eprint={2305.01582},
      archivePrefix={arXiv},
      primaryClass={astro-ph.IM},
      url={https://arxiv.org/abs/2305.01582}, 
}

@article{scikit-learn,
  title={Scikit-learn: Machine Learning in {P}ython},
  author={Pedregosa, F. and Varoquaux, G. and Gramfort, A. and Michel, V.
          and Thirion, B. and Grisel, O. and Blondel, M. and Prettenhofer, P.
          and Weiss, R. and Dubourg, V. and Vanderplas, J. and Passos, A. and
          Cournapeau, D. and Brucher, M. and Perrot, M. and Duchesnay, E.},
  journal={Journal of Machine Learning Research},
  volume={12},
  pages={2825--2830},
  year={2011}
}